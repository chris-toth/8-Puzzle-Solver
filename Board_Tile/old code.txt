// get the top board from priority and add it to visited boards
        Board_Tile queueTop = tileQueue.top();
        visited.push_back(queueTop);
        tileQueue.pop();

        // check the current board to see if we are done.
        if (queueTop.Manhattan_Distance() == 0) {
            std::cout << "         " << queueTop.numMoves() << "           " << queueTop.getMoves() << std::endl;

            while (!tileQueue.empty())
                tileQueue.pop();

            break;
        }

        // get a list of the next possible moves
        std::list<Board_Tile> next = queueTop.nextConfigs();

/// Problem is that it does not allow for worse board_tile configs to get better ones. Happens after step 9. Step 10 requires a worse config and Step 11 even worse
/// need a list of other options that could be valuable in the long run. how do I determine when to add the next board to which list?

        // add possible moves to the queue if they have not been checked before
        for (std::list<Board_Tile>::iterator nextIt = next.begin(); nextIt != next.end(); nextIt++)
        {
            Board_Tile nextTemp = *nextIt;

                // if the next tile board is better or the same than what we have
                if (nextTemp.Manhattan_Distance() <= queueTop.Manhattan_Distance()) {
                    if (nextTemp.getConfig() != queueTop.getConfig()) {
                        tileQueue.push(nextTemp); // board is good. push it to queue
                    }
                }
                else /*if (nextTemp.getConfig() != visited.back().getConfig())*/ { // may have potential add here to check later
                    other.push_back(nextTemp); /// NEEDS TO BE UNIQUE
                }
        }
        // if after checking for next tiles we find nothing of value try something we have not tried yet from the other list
        if (tileQueue.empty())
        {
            tileQueue.push(other.back());
            other.pop_back();
        }